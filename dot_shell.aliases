# vim: set filetype=sh
#
##########################
# Aliases & Functions
##########################
TMUX_POPUP_NAME="popup-session"

alias vim='nvim'
alias lvim='NVIM_APPNAME=lazyvim nvim'
alias mvim='NVIM_APPNAME=minivim nvim'

################################################################################
################################################################################
# A command to fetch all registered subdomains
################################################################################
################################################################################

subdomains() {
  name="${1:=saasak.studio}"
  url="https://subdomains.whoisxmlapi.com/api/v1?apiKey=at_5YimX3xqySyqdZc63cuTEnevrAFaR&domainName=${name}"
  curl "${url}" | jq '.result.records[].domain'
}

################################################################################
################################################################################
# Wrapper around the tree command
################################################################################
################################################################################

show_tree() {
  depth="${1:=1}"
  shift;
  tree -L $depth -I "node_modules|.git" --dirsfirst "$@"
}

################################################################################
################################################################################
# On linux, open nautilus with fzf
################################################################################
################################################################################

finder() {
    # Determine the system's file manager command
    if [ "$(uname)" = "Darwin" ]; then
        open_cmd="open"
    elif [ -n "$WAYLAND_DISPLAY" ] || [ -n "$DISPLAY" ]; then
        open_cmd="xdg-open"
    else
        echo "No suitable file manager found"
        return 1
    fi

    if [ -f "$1" ] || [ -d "$1" ]; then
        ("$open_cmd" "$1" &>/dev/null &)
    else
        dir=$(find . -type d | fzf-tmux -q "${1:-}")
        if [ -n "$dir" ] && [ -d "$dir" ]; then
            ("$open_cmd" "$dir" &>/dev/null &)
        else
            ("$open_cmd" . &>/dev/null &)
        fi
    fi
}

################################################################################
################################################################################
# Open an editor quickly
################################################################################
################################################################################

open_editor() {
  if [ -z "$1" ]; then
    file=$(ag --nofollow -l | fzf-tmux)

		[ -z "$file" ] \
			&& echo "No file selected" \
			|| $EDITOR "$file"
  else
    $EDITOR "$1"
  fi
}

################################################################################
################################################################################
# Failed attempt at a lighter zoxide
################################################################################
################################################################################

move_to_dir() {
  if [ -z "$1" ] || [ ! -d "$1" ]; then
    cd $(find . -type d | fzf-tmux -q "$1")
  else
    cd "$1"
  fi
}

################################################################################
################################################################################
# Utility to print tmux colors
################################################################################
################################################################################

print_tmux_colors() {
	for i in {0..255} ; do
		printf "\x1b[38;5;${i}mcolour${i}\n"
	done
}

################################################################################
################################################################################
# Floating tmux session. Does not work...
################################################################################
################################################################################

tmux_popup() {
	width=${1:-"80%"}
	height=${2:-"80%"}
	name="${TMUX_POPUP_NAME}"

	if [ ! -z "$TMUX" ]; then
		sess=$(tmux display-message -p -F "#{session_name}")

		# if we are in popup session
		if [ "${sess}" = "${name}" ]; then
			tmux detach-client
		else
			# check if popup session exists
			tmux has-session -t "${name}" &>/dev/null
			# if yes, attach to it in a popup
			if [ $? -eq 0 ]; then
				tmux popup -d '#{pane_current_path}' -xC -yC -w"$width" -h"$height" -E "tmux attach-session -t ${name}"
			# otherwise create a session in a popup
			else
				tmux popup -d '#{pane_current_path}' -xC -yC -w"$width" -h"$height" -E "tmux new-session -s ${name}"
			fi
		fi
	fi
}

################################################################################
################################################################################
# Quickly open a tmux session
################################################################################
################################################################################

tmux_open() {
  sess=${1}
	directory=${2}

	[ -z "${directory}" ] && directory="${pwd}"

  if [ -z "${sess}" ]; then
    nbSession=$(tmux list-sessions | grep -v "$TMUX_POPUP_NAME" | wc -l)

    if [ $nbSession -eq 0 ]; then
      # if no session, create a default one named default
      sess="default"
    else
      # if only one session, do not ask to select
      [ $nbSession -eq 1 ] \
        && sess=$(tmux list-sessions | grep -v "$TMUX_POPUP_NAME" | head -n 1 | cut -d ":" -f 1) \
        || sess=$(tmux list-sessions | grep -v "$TMUX_POPUP_NAME" | fzf-tmux | cut -d ":" -f 1)
    fi
  fi

  # check if we have a session with this name
  tmux has-session -t "${sess}" &>/dev/null

  # if not create a detached session with this name
  [ $? -eq 0 ] || (TMUX= tmux -u new-session -d -s "${sess}" -c "${directory}")

  # if inside tmux switch o/w attach to newly created detached session
  [ -z "$TMUX" ] && tmux -u attach-session -t "${sess}" || tmux -u switch-client -t "$sess"
}

################################################################################
################################################################################
# Quickly kill a tmux session
################################################################################
################################################################################

tmux_kill() {
  sess="${1}"

  if [ -z "${sess}" ]; then
		if [ -z "$TMUX" ]; then
			nbSession=$(tmux list-sessions | grep -v "$TMUX_POPUP_NAME" | wc -l)
			if [ $nbSession -eq 0 ]; then
				sess=""
			else
				# if only one session, do not ask to select
				[ $nbSession -eq 1 ] \
					&& sess=$(tmux list-sessions | grep -v "$TMUX_POPUP_NAME" | head -n 1 | cut -d ":" -f 1) \
					|| sess=$(tmux list-sessions | grep -v "$TMUX_POPUP_NAME" | fzf-tmux | cut -d ":" -f 1)
			fi

		# if inside tmux
		else
			seed=$(tmux display-message -p '#S') # kill current session
			sess=$(TMUX= tmux list-sessions | grep -v "$TMUX_POPUP_NAME" | fzf-tmux -q "${seed:-}" | cut -d ":" -f 1)
		fi
  fi

  tmux has-session -t "${sess}" &>/dev/null
  [ $? -eq 0 ] && (TMUX= tmux kill-session -t "${sess}")
}

tmux_kill_all() {
  # Get all sessions except popup
  sessions=$(tmux list-sessions | cut -d ":" -f 1)

	if [ ! -z "$sessions" ]; then
		echo "$sessions" | while read sess; do
			TMUX= tmux kill-session -t "$sess"
		done
	fi
}

################################################################################
################################################################################
# Quickly open a workspace
################################################################################
################################################################################

work_on() {
	workspace=$(find ~/Workspace/Projects -mindepth 1 -maxdepth 3 -type d -name ".git" -exec dirname {} \; | fzf-tmux -q ${1:-""})

	if [ ! -z "$workspace" ]; then
		lastname=$(basename "$workspace")
		firstname=$(basename $(dirname "$workspace"))
		tmux_open "${firstname}/${lastname}" "$workspace"
	else
		echo "No workspace selected"
	fi
}

################################################################################
################################################################################
# Quickly create a workspace
################################################################################
################################################################################

mkpro() {
	local projectDir="${HOME}/Workspace/Projects"
	local name="${1}"
	local scope=${2:-"perso"}

	if [ -z "${name}" ]; then
		echo "Usage: mkpro <name> [scope]"
		return 1
	fi

	if [ -d "${projectDir}/${scope}/${name}" ]; then
		echo "Project already exists"
		return 1
	fi

	mkdir -p "${projectDir}/${scope}/${name}"
	(cd "${projectDir}/${scope}/${name}" && git init --quiet)

	work_on "${scope}/${name}"
}

################################################################################
################################################################################
# Quickly kill a process on a port
################################################################################
################################################################################

__kill_ports() {
    if [ $# -eq 0 ]; then
        echo "Usage: __kill_ports port1 [port2 port3 ...]"
        return 1
    fi

    for port in "$@"; do
        echo "Killing processes on port $port..."
        lsof -ti:$port | xargs -I {} kill -9 {} 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "✓ Killed process(es) on port $port"
        else
            echo "✗ No process found on port $port"
        fi
    done
}

# Keep the old function for backward compatibility
__kill_port() {
    __kill_ports "$1"
}


################################################################################
################################################################################
# Change theme for the whole system
################################################################################
################################################################################

edit_cursor() {
	theme="${1:=eighties}"

	file="$HOME/Library/Application Support/Cursor/User/settings.json"
	tmp="$(mktemp)"

	if command -v jc >/dev/null 2>&1; then
		cat "$file" \
			| jc --json json  \
			| jq --arg t "base16-${theme}" '.["workbench.colorScheme"]=$t' \
			> "$tmp" && cat $tmp && rm "$tmp"
	fi
}

chth() {
  theme="${1:=eighties}"

	if command -v tinty >/dev/null 2>&1; then
		tinty apply "base16-${theme}"
		# local tinty_data_dir="${XDG_DATA_HOME:-$HOME/.local/share}/tinted-theming/tinty"
		# while read -r script; do
		# 	. "$script"
		# done < <(find "$tinty_data_dir" -maxdepth 1 -type f -o -type l -name "*.sh" -newer "$newer_file")
	elif command -v flavours >/dev/null 2>&1; then
		flavours --config "$HOME/.config/flavours/config.toml" apply "$theme"
	elif command -v base16-manager >/dev/null 2>&1; then
		sway="/home/georgio/.local/share/base16-manager/rkubosz/base16-sway/themes/base16-${theme}.config"
		base16-manager set "$theme" 2>/dev/null
		[ -f "${sway}" ] && cp "${sway}" "/home/georgio/.config/sway/colorscheme"
	else
		echo "No theme manager"
	fi
}

################################################################################
################################################################################
# Quickly clean  node_modules...
################################################################################
################################################################################

clean_workspaces() {
	workspaces=$(find ~/Workspace/Projects -mindepth 2 -maxdepth 3 -type d -name "node_modules" -exec dirname {} \; | fzf-tmux -m -q ${1:-""})
	while IFS= read -r w; do
		echo "... Cleaning $w ..."
		find "${w}" -maxdepth 3 -type d -name "node_modules" -exec rm -rf {} \; 2>/dev/null
	done <<< "$workspaces"
}

################################################################################
################################################################################
# Automatically run brew bundle dump when re-adding in chezmoi
# Splits Brewfile into common (cross-platform) and darwin (macOS-only)
################################################################################
################################################################################

_brew_split_brewfile() {
  # Disable xtrace for this function (too noisy)
  { local _xtrace_was_set=false; [[ $- == *x* ]] && _xtrace_was_set=true && set +x; } 2>/dev/null
  
  local brew_dir="$HOME/.config/brew"
  local tmp_brewfile="$brew_dir/.Brewfile.tmp"
  
  mkdir -p "$brew_dir"
  
  echo "Dumping current brew state..."
  # Dump current state (no casks, no vscode - those are always macOS)
  brew bundle dump --brews --taps --describe --force --file "$tmp_brewfile" 2>/dev/null
  
  # Initialize output files
  : > "$brew_dir/Brewfile.common"
  : > "$brew_dir/Brewfile.darwin"
  
  local taps_common=()
  local taps_darwin=()
  local brews_common=()
  local brews_darwin=()
  
  # Count total formulas for progress
  local total_formulas
  total_formulas=$(grep -c '^brew "' "$tmp_brewfile" 2>/dev/null || echo 0)
  local current=0
  
  # First pass: categorize all brews
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip empty lines and comments
    [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
    
    if [[ "$line" =~ ^tap\ \" ]]; then
      # Taps will be categorized based on their formulas later
      continue
    elif [[ "$line" =~ ^brew\ \" ]]; then
      current=$((current + 1))
      # Extract formula name (handle args like --HEAD)
      local formula
      formula=$(echo "$line" | sed 's/brew "\([^"]*\)".*/\1/')
      
      printf "\r  Checking formula %d/%d: %s                    " "$current" "$total_formulas" "$formula"
      
      # Query brew for platform info
      local is_macos_only=false
      local json_info
      json_info=$(brew info --json=v2 "$formula" 2>/dev/null)
      
      if [[ -n "$json_info" ]]; then
        # Check if bottles include linux or "all" (universal)
        # This takes priority over macos requirements (which may just be version checks)
        local bottle_keys
        bottle_keys=$(echo "$json_info" | jq -r '.formulae[0].bottle.stable.files // {} | keys[]' 2>/dev/null)
        
        if echo "$bottle_keys" | grep -qE "(linux|^all$)"; then
          # Has linux bottles or universal "all" bottle - cross-platform
          is_macos_only=false
        elif [[ -z "$bottle_keys" ]]; then
          # No bottles at all (HEAD-only builds) - check macos requirement
          local has_macos_req
          has_macos_req=$(echo "$json_info" | jq -r '.formulae[0].requirements[]?.name // empty' 2>/dev/null | grep -c "^macos$" || true)
          if [[ "$has_macos_req" -gt 0 ]]; then
            is_macos_only=true
          else
            # No bottles and no macos req - default to macOS for safety (HEAD-only)
            is_macos_only=true
          fi
        else
          # Has bottles but none for Linux and not universal - macOS only
          is_macos_only=true
        fi
      else
        # Can't query info - default to macOS for safety
        is_macos_only=true
      fi
      
      if [[ "$is_macos_only" == "true" ]]; then
        brews_darwin+=("$line")
        # Track tap for darwin
        if [[ "$formula" == */* ]]; then
          local tap="${formula%/*}"
          [[ ! " ${taps_darwin[*]} " =~ " ${tap} " ]] && taps_darwin+=("$tap")
        fi
      else
        brews_common+=("$line")
        # Track tap for common
        if [[ "$formula" == */* ]]; then
          local tap="${formula%/*}"
          [[ ! " ${taps_common[*]} " =~ " ${tap} " ]] && taps_common+=("$tap")
        fi
      fi
    fi
  done < "$tmp_brewfile"
  
  echo ""  # New line after progress
  
  # Re-read to get all taps
  local all_taps=()
  while IFS= read -r line; do
    if [[ "$line" =~ ^tap\ \" ]]; then
      local tap_name
      tap_name=$(echo "$line" | sed 's/tap "\([^"]*\)".*/\1/')
      all_taps+=("$tap_name")
    fi
  done < "$tmp_brewfile"
  
  # Categorize remaining taps (those not associated with specific formulas)
  # Default homebrew taps go to common, others to darwin for safety
  for tap in "${all_taps[@]}"; do
    if [[ " ${taps_common[*]} " =~ " ${tap} " ]]; then
      continue  # Already in common
    elif [[ " ${taps_darwin[*]} " =~ " ${tap} " ]]; then
      continue  # Already in darwin
    elif [[ "$tap" == homebrew/* ]]; then
      taps_common+=("$tap")
    else
      taps_darwin+=("$tap")
    fi
  done
  
  # Write Brewfile.common
  {
    echo "# Cross-platform Homebrew packages"
    echo "# Auto-generated by chez re-add"
    echo ""
    for tap in "${taps_common[@]}"; do
      echo "tap \"$tap\""
    done
    [[ ${#taps_common[@]} -gt 0 ]] && echo ""
    for brew_line in "${brews_common[@]}"; do
      echo "$brew_line"
    done
  } > "$brew_dir/Brewfile.common"
  
  # Write Brewfile.darwin
  {
    echo "# macOS-only Homebrew packages"
    echo "# Auto-generated by chez re-add"
    echo ""
    for tap in "${taps_darwin[@]}"; do
      echo "tap \"$tap\""
    done
    [[ ${#taps_darwin[@]} -gt 0 ]] && echo ""
    for brew_line in "${brews_darwin[@]}"; do
      echo "$brew_line"
    done
  } > "$brew_dir/Brewfile.darwin"
  
  # Cleanup
  rm -f "$tmp_brewfile"
  
  # Summary
  echo "Brewfile split complete:"
  echo "  Common (cross-platform): ${#brews_common[@]} packages"
  echo "  Darwin (macOS-only): ${#brews_darwin[@]} packages"
  
  # Restore xtrace if it was set
  { $_xtrace_was_set && set -x; } 2>/dev/null
}

chez() {
  if [ "$1" = "re-add" ]; then
    echo "Splitting Brewfile by platform compatibility..."
    _brew_split_brewfile
  fi
  command chezmoi "$@"
}

################################################################################
################################################################################
# Aliases
################################################################################
################################################################################

alias c='clear'

hash jc 2>/dev/null && hash mlr 2>/dev/null && alias li='\ls -la | jc --ls | mlr --ijson --opprint cut -f link_to -x' || alias li='\ls -la'
alias ls='ls'
alias lila='\ls -la'
alias lisa='\ls -lsah'

hash jc 2>/dev/null && alias what='__g() { \file "$1" | jc --file; }; __g' || what='file'
hash jc 2>/dev/null && alias lidi='\df -h | jc --df' || alias lidi='df'

alias mvd='move_to_dir'
alias edit='open_editor'
alias op='finder'
alias treee='show_tree'

alias home='cd $HOME'
alias work='work_on'

#################
# Tmux
#################

alias tm='tmux_open'
alias tmk='tmux_kill'
alias tmka='tmux_kill_all'
alias tmls='tmux list-sessions'
alias tmpop='tmux_popup'
alias tmcolors='print_tmux_colors'

#################
# Custom bins
#################

[ -e "$HOME/.local/bin/dot.sh" ] && alias dot='$HOME/.local/bin/dot.sh'

#################
# Remaps
#################

# hash podman 2>/dev/null && alias docker='podman'
# hash podman-compose 2>/dev/null && alias docker-compose='podman-compose'

hash bat 2>/dev/null && alias cat='bat'
hash diff-so-fancy 2>/dev/null && alias diff='diff-so-fancy'
hash hub 2>/dev/null && alias git='hub'
hash code-git 2>/dev/null && alias code='code-git'


#################
# Nix
#################

alias nix-ls-installed='nix profile list | fzf-tmux'
alias nix-ls-available='nix search nixpkgs'
alias nix-ls-generations='nix profile history'
alias nix-upgrade='[ -d ~/.config/nix ] && (cd ~/.config/nix && nix flake update && noglob nix profile upgrade .#homies)'
alias nix-rebuild='[ -d ~/.config/nix ] && (cd ~/.config/nix && nix profile remove --all && noglob nix profile add .#homies)'
alias nix-remove-all='[ -d ~/.config/nix ] && (cd ~/.config/nix && nix profile remove --all)'
alias nix-purge='[ -d ~/.config/nix ] && (cd ~/.config/nix && nix profile remove --all) && nix store gc'
alias nix-cleanup='nix profile wipe-history --older-than 3d && nix store gc'
alias nix-rollback='nix profile rollback'
alias nix-clean-store='nix store gc'

# Uninstall Nix
alias nix-uninstall='/nix/nix-installer uninstall'

alias devga='devbox global add'
alias devgc='nix-collect-garbage'
alias deva='devbox add'
alias devrm='devbox rm'
alias devse='devbox search'

#################
# TUI
#################

alias ldok="DOCKER_HOST=$(docker context ls --format json | jq '. | select(.Current == true) | .DockerEndpoint') lazydocker"
alias lgit='lazygit'

#################
# Network
#################

alias kport='__kill_port'
alias kports='__kill_ports'
alias nodeports='echo -e "PORT\tPID\tPACKAGE\tCOMMAND\n----\t---\t-------\t-------" && lsof -iTCP -sTCP:LISTEN -n -P | grep node | awk '"'"'{print $2, $9}'"'"' | while read pid port; do port_num=$(echo $port | cut -d: -f2); cwd=$(lsof -p $pid 2>/dev/null | grep cwd | awk '"'"'{print $NF}'"'"'); cmd=$(ps -p $pid -o command= 2>/dev/null | head -c 80); pkg=$(basename "$cwd" 2>/dev/null || echo "unknown"); echo -e "$port_num\t$pid\t$pkg\t$cmd"; done | sort -n | column -t -s $'"'"'\t'"'"
alias myip='dig +short txt ch whoami.cloudflare @1.0.0.1 | tr -d "\""'
alias find-rpi='arp -na | grep -i "dc:a6:32"'
alias find-old-rpi='arp -na | grep -i "b8:27:eb"'
